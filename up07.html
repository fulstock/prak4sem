<meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
<h3>Problem up07-1: up07-1</h3>
<p>
На стандартном потоке ввода подается последовательность строк, состоящих из непробельных символов и разделенных пробельными символами.
Напечатайте эту последовательность в обратном порядке по одной строке на одной строке выходного текстового файла.
</p>

<p>
Не используйте ни массивов, ни других контейнерных классов (вектор).
Допускается без изменений хранить входную строку в std::string.
Выход из рекурсии должен выполняться с помощью исключения. <b>Выход из рекурсивной функции с помощью явного или неявного return запрещен.</b>
Печать строки должна выполняться в деструкторе некоторого класса
при обработке исключения (свертке стека).
</p>

<h3>Problem up07-2: up07-2</h3>
<p>Некоторая рекурсивная функция func от трех целых аргументов a, b, k (a, b &gt;= 1, k &gt;= 0) определена следующим образом:</p>
<ul>
  <li>func(a, b, k) == a + b при k == 0</li>
  <li>func(a, b, k) == a при k &gt; 0, b == 1</li>
  <li>func(a, b, k) == f(a, f(a, b - 1, k), k - 1) при k &gt; 0, b &gt; 1</li>
</ul>

<p>На стандартном потоке ввода подаются тройки чисел: два 64-битных знаковых целых положительных числа a, b
и 32-битное целое неотрицательное число k. Для каждой тройки чисел на стандартный поток вывода напечатайте значение описанной выше функции.</p>

<p>Параметры на входе будут таковы, что вычисление завершится за разумное время. Для вычислений достаточно 64-битного целого знакового типа.</p>
      
<p>Для возврата значения из рекурсии используйте исключения.
<b>Выход из рекурсивной функции с помощью явного или неявного return запрещен.</b></p>

<p>Напишите свой класс
(например, Result) для передачи результата вычислений вместе с исключением.
Не используйте выбрасывание исключений базовых (например, int) типов.</p>

<p>В комментарии в начале программы опишите, что из себя представляет эта рекурсивная функция.</p>

<h3>Problem up07-3: up07-3</h3>
<p>Реализуйте класс <tt>S</tt> следующим образом:</p>
<ul>
  <li>Класс хранит целое число (типа int).</li>
  <li>Число считывается со стандартного потока ввода в конструкторе.</li>
  <li>Число выводится на стандартный поток вывода в деструкторе.</li>
  <li>Следующая программа:
<pre>using namespace std;
void func(S v)
{
    if (v) {
        func(move(v));
    }
}

int main()
{
    func(S());
}</pre>
  считывает последовательность целых чисел и выводит на стандартный поток вывода их сумму.</li>
  <li>Если входная последовательность пустая, программа не выводит ничего.</li>
</ul>

<p>Проверка на переполнение не требуется.</p>

<p>Глобальные переменные, <tt>static</tt>, <tt>mutable</tt> запрещены.</p>

<p>Сдаваемый на проверку класс должен подключать необходимые заголовочные файлы.</p>

    <h3>Examples</h3><h4>Input</h4>
<pre>1 2 3</pre>
<h4>Output</h4>
<pre>6</pre>

<h3>Problem up07-4: mz07-4</h3>
<pre>
(S, '0') → (S, '0', R)        
(S, '1') → (A, '1', R)        
(S, '#') → (S, '#', S)        
(A, '0') → (A, '0', R)        
(A, '1') → (S, '1', R)        
(A, '#') → (B, '#', L)
(B, '0') → (B, '0', L)
(B, '1') → (B, '1', L)
(B, '#') → (C, '#', R)
(C, '0') → (C, '0', R)        
(C, '1') → (D, '0', S)
(D, '0') → (D, '0', S)
</pre>
    <h3>Examples</h3><h4>Input</h4>
<pre>#0#</pre>
<h4>Output</h4>
<pre>#0#</pre>

<h3>Problem up07-5: mz07-5</h3>
<p>
Используйте только средства и библиотеки Си++ (например, boost.Date_Time). Библиотеками языка Си и POSIX пользоваться запрещено.
</p>
    <h3>Examples</h3><h4>Input</h4>
<pre>1985-10-26
1955-11-05
1955-11-12
1985-10-26
2015-10-21</pre>
<h4>Output</h4>
<pre>32848</pre>
<h4>Input</h4>
<pre>1990-01-01
1991-01-01
1990-01-01</pre>
<h4>Output</h4>
<pre>730</pre>