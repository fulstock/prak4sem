<meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
<h3>Problem up06-1: up06-1</h3>
<p>
Дано прямоугольное поле размером <i>m</i> строк на <i>n</i> столбцов клеток.
Левая нижняя клетка поля имеет координаты (0,0), правая верхняя
клетка поля &mdash; (m - 1,n - 1).
</p>

<p>Поле закольцовано в тор, то есть склеены верхняя и нижняя границы
поля и правая и левая границы поля.</p>

<p>
Из некоторой клетки можно перейти за один ход в любую из четырех
соседних клеток (если таковые существуют).
Например, из клетки (1,2) можно перейти в клетки (0,2), (2,2), (1,1), (1,3).
</p>

<p>
Расстояние между двумя клетками &mdash; это минимальное число ходов,
за которое можно перейти из одной клетки в другую.
</p>

<p>На стандартном потоке ввода задаются два целых числа m и n,
задающие размеры поля.</p>

<p>Далее вводятся четверки целых чисел r1, c1, r2, c2, задающие
координаты (r1,c1) первой и (r2,c2) второй клеток.</p>

<p>Для каждой четверки координат выведите на стандартный поток
вывода расстояние между этими клетками.</p>

<h3>Problem up06-2: up06-2</h3>
<p>
Дано прямоугольное поле размером <i>m</i> строк на <i>n</i> столбцов клеток.
Левая нижняя клетка поля имеет координаты (0,0), правая верхняя
клетка поля &mdash; (m - 1,n - 1).
</p>

<p>Поле закольцовано в тор, то есть склеены верхняя и нижняя границы
поля и правая и левая границы поля.</p>

<p>
Из некоторой клетки можно перейти за один ход в любую из восьми
соседних клеток.
Например, из клетки (1,2) можно перейти в клетки
(0,2), (2,2), (1,1), (1,3), (0, 1), (0, 3), (2, 1), (2, 3).
</p>

<p>
Расстояние между двумя клетками &mdash; это минимальное число ходов,
за которое можно перейти из одной клетки в другую.
</p>

<p>Напишите шаблонный класс <tt>Coord</tt>, параметризованный типом
координат. Класс должен содержать открытый тип <tt>value_type</tt>,
открытые поля <tt>row</tt>, <tt>col</tt> и открытый конструктор
от 0, 1 или 2 аргументов.</p>

<p>Напишите шаблонну функцию dist, принимающую три параметра:
размеры поля, две координаты клеток, которая вычисляет расстояние
между двумя клетками.</p>

<h3>Problem up06-3: up06-3</h3>
<p>
Дано прямоугольное поле из гексагональных элементов (см. рис)
размером <i>m</i> строк на <i>n</i> столбцов клеток.
Координаты шестиугольников определяются, как показано на рисунке.
</p>

<img src="hexagons.png" alt="hexagons"/>

<p>
Из некоторой клетки можно перейти за один ход в любую
из шести
соседних клеток.
</p>

<p>
Расстояние между двумя клетками &mdash; это минимальное число ходов,
за которое можно перейти из одной клетки в другую.
</p>

<p>В пространстве имен Game
напишите шаблонный класс <tt>Coord</tt>, параметризованный типом
координат. Класс должен содержать открытый тип <tt>value_type</tt>,
открытые поля <tt>row</tt>, <tt>col</tt> и открытый конструктор
от 0, 1 или 2 аргументов.</p>

<p>В пространстве имен Game напишите шаблонную функцию dist,
принимающую три параметра:
размеры поля, две координаты клеток, которая вычисляет расстояние
между двумя клетками.</p>

<h3>Problem up06-4: up06-4</h3><p>Реализовать класс строк с отложенным копированием при записи. Буфер для строки и дополнительные поля должны быть выделены в отдельную структуру (используйте идиому PIMPL).
    Интерфейс строки должен быть отделен от реализации.</p>
<pre>
String c, a = "abc";
String b = a; // в памяти хранится "abc" в одном экземпляре 
c = a; 
b += "aaa"; // для b создался новый "массив" символов.
c[1] = 'f'; // a не изменилось 
cout &lt;&lt; string(c);
</pre>

<p>Для хранения данных не используйте <tt>std::string</tt>
и умные указатели.</p>

<h3>Problem up06-5: up06-5</h3>
<p>В пространстве имен <tt>Equations</tt> определите шаблонную функцию <tt>quadratic</tt>, решающую уравнение <i>az</i><sup>2</sup>+<i>bz</i>+<i>c</i>=0
в поле комплексных чисел над любым вещественным типом, поддерживаемым в заголовочном файле <tt>&lt;complex&gt;</tt>.
Функция принимает массив (<tt>std::array</tt>) <tt>v</tt> из трех элементов комплексных коэффициентов уравнения (c - v[0], b - v[1], a - v[2]),
функция возвращает пару <tt>std::pair</tt> из булевского значения и вектора корней. Булевское
значение (<tt>first</tt>) равно <tt>false</tt>, если корней уравнения бесконечно много.
В противном случае <tt>first</tt> равно <tt>true</tt> и в векторе <tt>second</tt> возвращается вектор корней,
содержащий 0 элементов, если корней нет; 1 элемент, если уравнение имеет один корень (то есть линейное);
2 элемента, если уравнение имеет два корня (возможно, равные).
</p>

<p>Если на вход передается массив (std::array) другого размера или массив не комплексных чисел - поведение функции не определено.</p>

<p><b>Дополнительно (по указанию преподавателя)</b> предусмотрите EPS для сравнения std::norm() с нулем
равным 32 * epsilon() (см. std::numeric_limits).</p>

<p>Пример использования функции:</p>

<pre>int main()
{
    using namespace std::complex_literals;

    std::array v1{ 1.0 + 2.0i, 2.0 + 0i, 3 + 1.3i };

    auto [res, v2] = Equations::quadratic(v1);
    std::cout &lt;&lt; res;
}</pre>

<p>Или для стандарта C++11:</p>

<pre>int main()
{
    std::array&lt;std::complex&lt;double&gt;, 3&gt; v1{
        std::complex&lt;double&gt;(1.0, 2.0),
        std::complex&lt;double&gt;(2.0, 0),
        std::complex&lt;double&gt;(3, 1.3)
    };

    auto res = Equations::quadratic(v1);
    std::cout &lt;&lt; res.first;
}</pre>