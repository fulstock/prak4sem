<meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
<h3>Problem up08-1: up08-1</h3>
<p>
Дан язык L={&alpha;&beta;}, где
&alpha;={3,4}<sup>n</sup>, &beta;={1,2}<sup>m</sup>, n &gt;= 0,
m &gt;= 0.
</p>

<p>
На стандартном потоке подаются строки, разделяющиеся
пробельными символами.
Для каждой строки на стандартный поток вывода
напечатайте 1, если строка принадлежит языку,
и 0 в противном случае.
</p>

<h3>Problem up08-2: up08-2</h3>

<p>Дан язык L={(0<sup>k</sup>1<sup>m</sup>)<sup>n</sup>, k &gt; 0, m &gt; 0, n &gt; 0 }.
То есть язык состоит из слов (цепочек) из символов <tt>0</tt> и <tt>1</tt>, таких, что первая группа нулей и единиц
далее повторяется с тем же числом нулей и единиц произвольное число раз.</p>

<p>
На стандартном потоке подаются строки, разделяющиеся
пробельными символами.
Для каждой строки на стандартный поток вывода
напечатайте 1, если строка принадлежит языку,
и 0 в противном случае.
</p>

        

    <h3>Examples</h3><h4>Input</h4>
<pre>01
010101
000011000011000011 00001100011000011</pre>
<h4>Output</h4>
<pre>1
1
1
0</pre>

<h3>Problem up08-3: up08-3</h3>
<p>На вход подается описание грамматики в следующем виде: каждое правило состоит из двух символьных строк, разделяемых произвольным количеством
пробельных символов. Грамматика представляет собой последовательность правил. Таким образом, на вход подается четное число
строк, разделяемых произвольным количеством пробельных символов.</p>

<p>В строках допускаются:</p>
<ul>
  <li>Заглавные латинские буквы, обозначающие нетерминалы.</li>
  <li>Строчные латинские буквы и цифры, обозначающие терминалы.</li>
  <li>Символ подчеркивания, обозначающий пустую правую часть (эпсилон).</li>
</ul>

<p>Символ подчеркивания может находится только в правой части правила, в этом случае он является единственным символом в правой части.</p>

<p>Начальный нетерминал грамматики всегда 'S'.</p>

<p>На стандартный поток вывода напечатайте:</p>

<ul>
  <li><tt>-1</tt> если входное описание грамматики не является грамматикой, то есть
  не содержит правил, содержит только терминалы в левой части какого-либо правила,
  не содержит правила с единственным нетерминалом 'S' в левой части.</li>
  <li><tt>2</tt> если грамматика является контекстно-свободной, но не неукорачивающей контекстно-свободной.</li>
  <li><tt>23</tt> если грамматика является неукорачивающей контестно-свободной.</li>
  
  <li><tt>10</tt> в противном случае</li>
</ul>

<p>В неукорачивающей КС-грамматике допускается единственная пустая правая часть правила для S при условии,
что S не встречается в правой части никаких правил.</p>

<p>В контекстно-свободной грамматике пустые правые части допускаются везде.</p>

    <h3>Examples</h3><h4>Input</h4>
<pre>S abS
S ceA
A zA
A b
      </pre>
<h4>Output</h4>
<pre>23</pre>

<h3>Problem up08-4: up08-4</h3>

<p>Напишите шаблонный класс <tt>Range</tt>, который реализует поддержку диапазонов любых знаковых целых чисел.</p>
      
<p>Класс должен иметь поля <tt>low</tt> и <tt>high</tt>, класс представляет целые значения в диапазоне [low,high] (границы включены).</p>

<p>Определите конструктор по умолчанию, от одного и двух целых аргументов. Недостающие аргументы равны значению по умолчанию.
Если нарушено условие low &lt;= high, должно выбрасываться исключение <tt>std::invalid_argument</tt>.</p>

<p>Определите явный (explicit) конструктор из строки <tt>std::string</tt>, который преобразует строку в формате
<tt>(LOW,HIGH)</tt> в значение класса, где LOW, HIGH &mdash; значения типа носителя, причем low &lt;= high.
В случае ошибки преобразования должно выбрасываться исключение <tt>std::invalid_argument</tt>.
В случае ошибки переполнения должно выбрасываться исключение <tt>std::range_error</tt>.
Пробельные символы в формате отсутствуют.</p>

<p>Определите метод <tt>to_string</tt> для преобразования в строку <tt>std::string</tt>, который использует формат
преобразования, описанный выше.</p>

<p>Определите методы <tt>get_low</tt>, <tt>get_high</tt>.</p>

<p>Определите бинарные операции <tt>+</tt>, <tt>-</tt> и <tt>*</tt> и унарную операцию <tt>-</tt>. Результатом операций
является новый диапазон, являющийся диапазоном наименьшей длины, в который гарантированно попадают результаты выполнения
соответствующей операции над произвольными числами исходных диапазонов. Например,
<tt>(1,2) + (-3, 4) == (-2, 6)</tt>.</p>

<p>Если типом шаблона является знаковый стандартный тип (signed char, ..., long long),
при выполнении операций должно контролироваться переполнение. В случае обнаружения переполнения должно
выбрасываться исключение <tt>std::overflow_error</tt>.
Если типом шаблона является пользовательский тип, контроль переполнения возлагается на него.
</p>

<p>Если типом шаблона является пользовательский тип, для него должны быть определены все операции,
позволяющие использовать его вместо стандартного целого типа (в контексте реализации Range).
Кроме того, для него должен быть определен явный конструктор преобразования из std::string,
и операция вывода в поток. Вам не нужно реализовывать такой пользовательский тип,
но класс Range будет тестироваться с таким пользовательским типом.</p>

<p>Если типом шаблона не является ни пользовательский, ни стандартный знаковый тип
программа не должна компилироваться.</p>

<p>Вспомогательные сущности (шаблоны, функции, классы, ...) поместите в отдельное пространство имен <tt>RangeImpl</tt>,
чтобы они не "засоряли" глобальное пространство имен.</p>