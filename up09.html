<meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
<h3>Problem up09-1: up09-1</h3>
<p>
Язык L задается с помощью грамматики:
</p>

<pre>
S = aXPQ
P = YXP | &epsilon;
Q = UVQ | &epsilon;
aY = aa
aU = a0
0U = 00
0X = 0b
bX = bb
bV = b1
1V = 11
XY = YX
UY = YU
VY = YV
XU = UX
VU = UV
VX = XV
</pre>

<p>
Нетерминальные символы обозначаются заглавными буквами,
а терминальные символы &mdash; строчными буквами и цифрами.
Начальный нетерминал &mdash; S.
</p>

<p>
На стандартном потоке подаются строки, разделяющиеся
пробельными символами.
Для каждой строки на стандартный поток вывода
напечатайте 1, если строка принадлежит языку,
и 0 в противном случае.
</p>

<p>
Указание: определите тип языка и преобразуйте грамматику
к соответствующему типу. Грамматику запишите в комментарии
в начале программы.
</p>

<h3>Problem up09-2: up09-2</h3>
<p>
Дан язык L, порождаемый следующей грамматикой:<br/>
S &rarr; C<tt>0</tt> | C<tt>1</tt><br/>
A &rarr; A<tt>0</tt> | A<tt>1</tt> | <tt>0</tt> | <tt>1</tt><br/>
B &rarr; A<tt>1</tt> | <tt>1</tt><br/>
C &rarr; B<tt>0</tt> | B<tt>1</tt><br/>
</p>

<p>
На стандартном потоке подаются строки, разделяющиеся
пробельными символами.
Для каждой строки на стандартный поток вывода
напечатайте 1, если строка принадлежит языку,
и 0 в противном случае.
</p>

<p>
Для анализа строк используйте лексический анализатор (конечный автомат).
</p>


<h3>Problem up09-3: up09-3</h3>
<p>На вход подается описание грамматики в следующем виде: каждое правило состоит из двух символьных строк, разделяемых произвольным количеством
пробельных символов. Грамматика представляет собой последовательность правил. Таким образом, на вход подается четное число
строк, разделяемых произвольным количеством пробельных символов.</p>

<p>В строках допускаются:</p>
<ul>
  <li>Заглавные латинские буквы, обозначающие нетерминалы.</li>
  <li>Строчные латинские буквы и цифры, обозначающие терминалы.</li>
  <li>Символ подчеркивания, обозначающий пустую правую часть (эпсилон).</li>
</ul>

<p>Символ подчеркивания может находится только в правой части правила, в этом случае он является единственным символом в правой части.</p>

<p>Начальный нетерминал грамматики всегда 'S'.</p>

<p>Гарантируется, что входная грамматика &mdash; контекстно-свободная (в том числе укорачивающая),
то есть удовлетворяет правилам, описанным в задаче 'is-context-free'.</p>

<p>На стандартный поток вывода напечатайте:</p>

<ul>
  <li><tt>2</tt> если грамматика является контекстно-свободной, но не неукорачивающей контекстно-свободной и не регулярной.</li>
  <li><tt>21</tt> если грамматика является неукорачивающей контестно-свободной, но не является регулярной.</li>
  <li><tt>31</tt> если грамматика является леволинейной регулярной грамматикой, но не является левоавтоматной</li>
  <li><tt>311</tt> если грамматика является левоавтоматной грамматикой</li>
  <li><tt>32</tt> если грамматика является праволинейной регулярной грамматикой, но не является правоавтоматной</li>
  <li><tt>321</tt> если грамматика являеся правоавтоматной грамматикой</li>
</ul>

<p>В случае неоднозначности выводите меньший номер.</p>

<p>В леволинейной или праволинейной грамматике в правой части правил допускается произвольное (в том числе нулевое)
количество терминальных символов. В лево- или право-автоматной грамматике в правой части правил всегда должен присутствовать
ровно один терминал. Но в автоматной грамматике в качестве исключения допускаются <b>два</b> правила для вывода пустой цепочки из S вида:</p>
<pre>
S _
S A
</pre>

<p>В этом случае грамматика со стартовым нетерминалом A должна
быть автоматной в строгом смысле, а нетерминал S не должен
использоваться в правых частях правил.</p>

    <h3>Examples</h3><h4>Input</h4>
<pre>S abS
S ceA
A zA
A b
      </pre>
<h4>Output</h4>
<pre>32</pre>

<h3>Problem up09-4: up09-4</h3>
<p>
Язык <i>L</i><sub>1</sub> = { <tt>a</tt><sup><i>n</i></sup><tt>b</tt><sup><i>m</i></sup><tt>c</tt><sup><i>m</i></sup><tt>d</tt><sup><i>n</i></sup> | <i>m</i>, <i>n</i> &gt; 0 }.
Для данного целого числа <i>k</i> (0 &lt; <i>k</i> &lt; 1000) напечатайте все строки длины <i>k</i>, принадлежащие
данному языку, в лексикографическом порядке. Запоминать строки в памяти не допускается.
Использование вспомогательных переменных не допускается. Каждую строку выводите на отдельной строке текста.
</p>

<p>Решение реализуйте с помощью рекурсивного спуска, добавляя вместо проверки входной строки генерацию выходной строки.
В начале решения напишите грамматику для данного языка, допускающую рекурсивный спуск.</p>

<p>Вы можете использовать <b>одну</b> переменную для чтения входного параметра.
Рекурсивные функции могут принимать не более двух целых параметров: входной параметр и дополнительный параметр генерации.</p>


    <h3>Examples</h3><h4>Input</h4>
<pre>4</pre>
<h4>Output</h4>
<pre>abcd</pre>

<h3>Problem up09-5: up09-5</h3>
<p>На вход подается описание КС-грамматики в следующем формате:</p>
<p>
&lt;левая часть&gt; &lt;правая часть&gt;
</p>
<p>
где &lt;...&gt; – строки, состоящие из цифр, строчных и заглавных латинских символов, а также символа ‘_’, означающего пустую цепочку (эпсилон).</p>
<p>Строчные символы и цифры – терминальные (из Т).<br/>
Заглавные – нетерминальные (из N).<br/>
Правила грамматики задаются не в сокращенной форме.
</p>
<p>На выходе программа должна вывести:<br/>
правила эквивалентной грамматики без недостижимых символов не в сокращенной форме.</p>
<p>
Пример
</p>
<p><b>
Вход</b></p>
<p>
S a<br/>
S Bc<br/>
D e<br/>
</p>
<p><b>
Выход</b></p>
<p>
S a<br/>
S Bc

</p>

<h3>Problem up09-6: up09-6</h3>
<p>Напишите программу, моделирующую работу детерминированного
конечного автомата (ДКА). Описание автомата и входная строка
вводятся на стандартном потоке ввода. Результат работы автомата
над данной строкой выводится на стандартный поток вывода.</p>

<p>Описание автомата задаётся в следующей форме. Сначала задаётся функция
перехода автомата. Функция перехода задаётся в виде троек
</p>

<pre>CUR CHAR NEW</pre>

<p>
где <tt>CUR</tt> &mdash; идентификатор исходного состояния &mdash; произвольная
символьная строка, не содержащая пробельные символы. <tt>CHAR</tt> &mdash; символьная
строка длиной ровно 1 символ. <tt>NEW</tt> &mdash; идентификатор целевого
состояния &mdash; произвольная символьная строка, не содержащая
пробельные символы. Элементы описания перехода могут отделятся друг от
друга произвольным количеством пробельных символов. Описание
функции перехода завершается строкой <tt>END</tt> в качестве идентификатора
исходного состояния. Элементы <tt>CHAR</tt> и <tt>NEW</tt> отсутствуют.</p>

<p>Далее перечисляются заключительные состояния автомата.
Каждое состояние &mdash; это символьная строка.
Список состояний завершается символьной строкой
<tt>END</tt>.</p>

<p>Далее задаётся начальное состояние автомата &mdash; символьная строка.
Затем задаётся проверяемое слово &mdash; символьная строка.
Все элементы входного файла могут отделяться друг от друга произвольным
количеством пробельных символов.</p>

<p>Можете предполагать, что входные данные корректны, то есть удовлетворяют
спецификации и действительно задают детерминированный конечный автомат.</p>

<p>
Результат работы автомата должен быть напечатан в следующем виде.
Сначала напечатайте число 1, если данный автомат допускает данную цепочку,
и 0 в противном случае. Затем напечатайте количество символов, прочитанных
во входной цепочке к моменту принятия автоматом решения (текущий символ не
считается прочитанным). Наконец,
напечатайте идентификатор состояния, в котором в данный момент
находился автомат.</p>
    <h3>Examples</h3><h4>Input</h4>
<pre>A a A
A b B
B a C
B b B
C a C
END
B C END
A
aaabbbbba</pre>
<h4>Output</h4>
<pre>1
9
C</pre>
<h4>Input</h4>
<pre>A a A
A b B
B a C
B b B
C a C
END
B C END
A
abab</pre>
<h4>Output</h4>
<pre>0
3
C</pre>