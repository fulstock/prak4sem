<meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
<h3>Problem up02-1: mz02-1 (дореш)</h3>

<p>
В пространстве имен <tt>numbers</tt> реализуйте класс <tt>complex</tt> для комплексных чисел
над типом <tt>double</tt>.
Класс должен определять:</p>
<ul>
  <li>Конструкторы по умолчанию, от одного и двух аргументов. Должен реализовываться одним конструктором.</li>
  <li>Явный (explicit) конструктор из типа <tt>std::string</tt>, который преобразовывает строку в значение complex.
  Строка имеет формат <tt>(RE,IM)</tt>, то есть вещественная и мнимая части (числа типа <tt>double</tt>)
  записываются через запятую в круглых скобках. Например, строка <tt>"(1.0,-5)"</tt> определяет
  комплексное число (1.0,-5.0). Проверка на ошибки не требуется.</li>
  <li>Методы <tt>re</tt> и <tt>im</tt> для получения вещественной и мнимой части числа.</li>
  <li>Метод <tt>abs2</tt> для получения квадрата модуля числа.</li>
  <li>Метод <tt>abs</tt> для получения модуля числа.</li>
  <li>Метод <tt>to_string</tt>,
  который преобразовывает комплексное число в строковое представление (см. выше) и возвращает объект типа std::string. Вещественные числа выводятся с 10 значащими цифрами в формате %.10g.</li>
  <li>Операции +=, -=, *=, /=.</li>
  <li>Операции сложения, вычитания, умножения и деления в обычной инфиксной форме, которые должны быть определены через соответствующие операции присваивания.</li>
  <li>Префиксную операцию <tt>~</tt>, которая возвращает новое число, комплексно-сопряженное к аргументу.</li>
  <li>Префиксную операцию <tt>-</tt> смены знака.</li>
</ul>

<h3>Problem up02-2: mz02-2 (дореш)</h3>

<p>
В пространстве имен <tt>numbers</tt> реализуйте класс <tt>complex_stack</tt>,
который будет реализовывать функциональность иммутабельного стека комплексных чисел из предыдущей задачи.
</p>

<p>
Реализация не должна использовать стандартные контейнерные классы (<tt>vector</tt>, <tt>stack</tt> и т. п.).
</p>

<p>Класс должен реализовывать:</p>
<ul>
  <li>конструктор по умолчанию.</li>
  <li>конструкторы, деструкторы и операции, необходимые для корректного управления памятью.</li>
  <li>метод <tt>size</tt> для получения числа элементов в стеке (возвращает size_t).</li>
  <li>доступ к произвольному элементу стека только на чтение с помощью операции <tt>[]</tt>.</li>
  <li>бинарный оператор <tt>&lt;&lt;</tt>, у которого первый аргумент - <tt>complex_stack</tt>, а второй аргумент - <tt>complex</tt>,
  бинарный оператор возвращает новый стек, в который добавлен указанный элемент. Исходный стек не изменяется.</li>
  <li>унарный оператор <tt>+</tt>, который возвращает элемент типа <tt>complex</tt> с вершины стека.</li>
  <li>унарный оператор <tt>~</tt>, который удаляет один элемент из стека и возвращает модифицированный стек,
  исходный стек при этом не изменяется.</li>
</ul>

<p>
На проверку сдавайте только класс <tt>complex_stack</tt>.
</p>

<p>
Возможные ошибки (извлечение из пустого стека, доступ за пределами стека) игнорируйте.
</p>

<p><b>Дополнительно реализуйте:</b></p>
<ul>
  <li>Семантику переноса в конструкторе, присваивании и операциях <tt>&lt;&lt;</tt> и <tt>~</tt></li>
  <li>placement new для минимизации вызовов конструкторов при перевыделении памяти</li>
</ul>

<h3>Problem up02-3: mz02-3 (дореш)</h3>

<p>
В пространстве имен <tt>numbers</tt> реализуйте
функцию <tt>eval</tt> с прототипом:
</p>

<pre>complex eval(const std::vector&lt;std::string&gt; &amp;args, const complex &amp;z);</pre>

<p>Функции подается на вход польская инверсная запись выражения над комплексными числами с одной переменной и значение
переменной. В качестве результата функция возвращает вычисленное значение.</p>

<p>Каждый элемент польской записи находится в отдельном элементе вектора.</p>

<p>Возможные ошибки при вычислении игнорируйте.</p>

<p>Вы должны сдать только функцию <tt>eval</tt>.</p>

<p>В польской записи допускаются следующие элементы:</p>
<ul>
  <li>Запись комплексного числа в виде (RE,IM) (см. предыдущие задачи).</li>
  <li>Обозначение переменной "z" (строчная латинская буква).</li>
  <li>Знаки бинарных операций <tt>+</tt>, <tt>-</tt>, <tt>*</tt>, <tt>/</tt>.</li>
  <li>Знак унарной операции <tt>!</tt>, которая заносит в стек элемент, находящийся на верхушке стека.</li>
  <li>Знак унарной операции <tt>;</tt>, которая удаляет элемент с верхушки стека.</li>
  <li>Знак унарной операции <tt>~</tt>, которая вычисляет комплексно-сопряженное число.</li>
  <li>Знак унарной операции <tt>#</tt>, которая меняет знак у числа.</li>
</ul>

<p>Обратите внимание, что польская запись <tt>z1 z2 -</tt> обозначает <tt>(z1 - z2)</tt>, а не <tt>(z2 - z1)</tt>!</p>

<p>Каждая строка в массиве строк содержит ровно один элемент польской записи. Пробельные символы отсутствуют.</p>

<p>Реализуйте отображение из операций в действия с помощью
отображения (std::map) анонимных функций.</p>

<h3>Problem up02-4: mz02-4 (дореш)</h3>

<p>
Программе в аргументах командной строки передаются:
</p>
<ul>
  <li>Комплексное число C.</li>
  <li>Вещественное число R.</li>
  <li>Целое число N.</li>
  <li>Остальные аргументы - запись функции одного комплексного аргумента в польской записи.</li>
</ul>

<p>На стандартный поток вывода напечатайте комплексное число I - результат вычисления криволинейного интеграла
по замкнутому контуру - окружности с центром в точке C и радиусом R.</p>

<p>Для вычисления используйте метод прямоугольников. Для этого окружность делится на N частей.</p>

<p>В заголовочном файле <tt>cmc_complex.h</tt> находится реализация
класса <tt>numbers::complex</tt>, в заголовочном файле
<tt>cmc_complex_stack.h</tt> находится реализация класса
<tt>numbers::complex_stack</tt>, в заголовочном файле
<tt>cmc_complex_eval.h</tt> находится реализация функции <tt>eval</tt>.</p>

